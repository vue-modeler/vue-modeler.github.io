---
title: Введение
description: Обзор архитектуры и основных концепций Vue Modeler
---

**Vue Modeler** — комплексное решение для управления состоянием в Vue.js приложениях, состоящее из двух взаимодополняющих библиотек:

  - **@vue-modeler/dc** - контейнер для хранения и повторного использования любых зависимостей в Vue.js приложениях.
  - **@vue-modeler/model** - библиотека для управления состоянием на основе моделей (реактивных объектов) для [Vue.js](https://vuejs.org/).
    
## Зачем разные библиотеки?

У библиотек разная ответственность. Они решают не пересекающиеся задачи. Можно использовать по отдельности. 

Вместе - полноценное решение для управления состоянием, жизненным циклом и внедрением зависимостей.

  - сильно уменьшает объем шаблонного кода
  - обеспечивает унифицированный подход к управлению состоянием, и выполенению шаблонных задач: отмена, блокировка, обработка исключений,
  - помогает разделить код на слои: UI, бизнес-логика, инфраструктура.
  
## Ключевые концепции

- **Контейнер зависимостей** обеспечивает жизненный цикл зависимостей. Поддерживает разные стратегии хранения зависимостей. 
- **Модель** - реактивный объект с состоянием и методами для его изменения.
- **Действие** - это объект с реактивным состоянием и поведением, а не метод.



## Ключевые особенности

- **Нет глобального хранилища состояния**.
  Нет хранилища — нет проблем. Состояние инкапсулировано в модели и является реактивным.
  Вне модели оно доступно только для чтения и наблюдения.

- **В основе ООП**.
  Модель определяется как стандартный TypeScript класс.
  Наследование, инкапсуляция, полиморфизм, деструктор доступны по умолчанию.

- **Поддержка внедрения зависимостей**.
  Модель принимает зависимости как аргументы конструктора, а не импортирует напрямую из других модулей.

- **Простое управление жизненным циклом модели**.
  Не нужно думать как создать, получить или удалить модель после использования -
  за это отвечает контейнер и провайдер.
  
- **Модульность**.
  Внедрение зависимостей избавляет от прямых импортов.
  Это позволяет легко извлекать связанные по смыслу модели в отдельные модули и использовать в других проектах.

- **Сохраняет типобезопасность**.
  Все подсказки автодополнения будут работать как внутри, так и вне контекста класса.

- **Реактивность Vue**. 
Всё работает на основе реактивности Vue. Не нужно изучать дополнительные API
или подходы для создания реактивных объектов.
  
---

## Причины создания 

### Шаблонный код в действиях

**Проблема:**
  Действия часто сопровождаются повторяющимся кодом для отслеживания состояния выполнения
  через дополнительные переменные: `isLoading`, `isPending`.
  В этом коде нет ценности для бизнес-логики, но он раздувает кодовую базу.

**Решение:**
 Действие - это объект с реактивными свойствами, отражающими статус его выполнения:
 `ready`, `pending`, `lock`, `abort`, `error`. Дополнительный код не нужен.

### Отмена или блокировка действия

**Проблема:** Отмена или блокировка действия не частая, но необходимая операция.
Все решают эту задачу по-своему, но в основе лежит общий паттерн.
Разные реализации одного и того же паттерна усложняют поддержку и повторное использование.

**Решение:** Действие содержит методы `lock` и `abort` для блокировки и отмены выполнения.
Не нужно писать дополнительный код и поддерживать его.

### Обработка исключений

**Проблема:** Обработка исключений дополнительный источник проблем: 
- разработчики забывают о ней,
- каждый разработчик обрабатывает её по-своему,
- регламенты не гарантируют, что  исключения будет обработано как нужно,
- обработка требует всегда внимательного ревью кода.

**Решение:** Действие перехватывает исключения, сохраняет их как часть состояния
и предоставляет единый интерфейс для обработки. Разработчик не сможет обрабатывать их по другому.

### Устаревшие паттерны

**Проблема:**  Pinia использует устаревший паттерн фабричной функции для создания хранилища.
Такое решение "тянет" за собой дополнительные шаблоны для эмуляции наследования и полиморфизма.

**Решение:** Поддержка классов и ООП из коробки.

### Слишком много реактивности 

**Проблема:** Хранилище Pinia - это объект с реактивными свойствами.
Но внутри фабричной функции это реактивные переменные, созданные с помощью Reactivity API Vue.
Получаем двойную реактивность и разные интерфейсы взаимодействия на одних и тех же данных.

**Решение:** Модели - это shallow reactive объекты из коробки.
Публичные и защищенные свойства будут реактивны снаружи и внутри 
без явного применения АПИ реактивности Vue.

## Следующие шаги

Теперь, когда вы понимаете основные концепции Vue Modeler, вы можете:

1. [Установить библиотеку](/installation/)
2. [Изучить быстрый старт](/getting-started/)
3. [Познакомиться с моделями](/guides/models/)
4. [Изучить действия](/guides/actions/) 