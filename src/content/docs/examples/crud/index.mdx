---
title: CRUD операции
description: Пример CRUD операций с Vue Modeler
---

# CRUD операции

В этом примере мы создадим полноценное CRUD приложение для управления пользователями, демонстрирующее все основные операции: Create, Read, Update, Delete.

## Модель пользователей

```typescript
// UserModel.ts
import { ProtoModel } from 'vue-modeler'
import { action } from 'vue-modeler/decorator'

interface User {
  id: number
  name: string
  email: string
  role: string
  createdAt: Date
}

interface CreateUserData {
  name: string
  email: string
  role: string
}

interface UpdateUserData {
  name?: string
  email?: string
  role?: string
}

export class UserModel extends ProtoModel {
  users: User[] = []
  selectedUser: User | null = null
  filters = {
    search: '',
    role: 'all'
  }

  @action async fetchUsers(): Promise<void> {
    try {
      const response = await fetch('/api/users')
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      this.users = await response.json()
    } catch (error) {
      console.error('Failed to fetch users:', error)
      throw error
    }
  }

  @action async createUser(userData: CreateUserData): Promise<void> {
    try {
      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData)
      })
      
      if (!response.ok) {
        throw new Error(`Failed to create user: ${response.statusText}`)
      }
      
      const newUser: User = await response.json()
      this.users.push(newUser)
    } catch (error) {
      console.error('Failed to create user:', error)
      throw error
    }
  }

  @action async updateUser(id: number, updates: UpdateUserData): Promise<void> {
    try {
      const response = await fetch(`/api/users/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates)
      })
      
      if (!response.ok) {
        throw new Error(`Failed to update user: ${response.statusText}`)
      }
      
      const updatedUser: User = await response.json()
      this.users = this.users.map(user => 
        user.id === id ? updatedUser : user
      )
      
      if (this.selectedUser?.id === id) {
        this.selectedUser = updatedUser
      }
    } catch (error) {
      console.error('Failed to update user:', error)
      throw error
    }
  }

  @action async deleteUser(id: number): Promise<void> {
    try {
      const response = await fetch(`/api/users/${id}`, {
        method: 'DELETE'
      })
      
      if (!response.ok) {
        throw new Error(`Failed to delete user: ${response.statusText}`)
      }
      
      this.users = this.users.filter(user => user.id !== id)
      
      if (this.selectedUser?.id === id) {
        this.selectedUser = null
      }
    } catch (error) {
      console.error('Failed to delete user:', error)
      throw error
    }
  }

  @action async fetchUser(id: number): Promise<void> {
    try {
      const response = await fetch(`/api/users/${id}`)
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      this.selectedUser = await response.json()
    } catch (error) {
      console.error('Failed to fetch user:', error)
      throw error
    }
  }

  setFilter(field: keyof typeof this.filters, value: string): void {
    this.filters[field] = value
  }

  selectUser(user: User | null): void {
    this.selectedUser = user
  }

  get filteredUsers(): User[] {
    let filtered = this.users

    // Фильтрация по поиску
    if (this.filters.search) {
      const search = this.filters.search.toLowerCase()
      filtered = filtered.filter(user => 
        user.name.toLowerCase().includes(search) ||
        user.email.toLowerCase().includes(search)
      )
    }

    // Фильтрация по роли
    if (this.filters.role !== 'all') {
      filtered = filtered.filter(user => user.role === this.filters.role)
    }

    return filtered
  }

  get totalUsers(): number {
    return this.users.length
  }

  get filteredUsersCount(): number {
    return this.filteredUsers.length
  }

  get hasSelectedUser(): boolean {
    return this.selectedUser !== null
  }
}
```

## Провайдер модели

```typescript
// userProvider.ts
import { model } from 'vue-modeler'
import { UserModel } from './UserModel'

export const userModelProvider = model(() => new UserModel())
```

## Vue компонент

```vue
<!-- UserManagementApp.vue -->
<template>
  <div class="user-management">
    <h1>Управление пользователями</h1>

    <!-- Статистика -->
    <div class="stats">
      <div class="stat-item">
        <span>Всего пользователей:</span>
        <strong>{{ userModel.totalUsers }}</strong>
      </div>
      <div class="stat-item">
        <span>Отфильтровано:</span>
        <strong>{{ userModel.filteredUsersCount }}</strong>
      </div>
    </div>

    <!-- Фильтры -->
    <div class="filters">
      <input 
        v-model="userModel.filters.search"
        placeholder="Поиск по имени или email..."
        class="search-input"
      />
      <select v-model="userModel.filters.role" class="role-filter">
        <option value="all">Все роли</option>
        <option value="admin">Администратор</option>
        <option value="user">Пользователь</option>
        <option value="moderator">Модератор</option>
      </select>
    </div>

    <!-- Кнопки действий -->
    <div class="actions">
      <button 
        @click="refreshUsers"
        :disabled="userModel.fetchUsers.isPending"
        class="btn btn-primary"
      >
        <span v-if="userModel.fetchUsers.isPending">Обновление...</span>
        <span v-else>Обновить</span>
      </button>
      
      <button 
        @click="showCreateForm = true"
        class="btn btn-success"
      >
        Добавить пользователя
      </button>
    </div>

    <!-- Индикаторы загрузки -->
    <div v-if="userModel.fetchUsers.isPending" class="loading">
      Загрузка пользователей...
    </div>

    <!-- Ошибки -->
    <div v-if="userModel.fetchUsers.isError" class="error">
      Ошибка загрузки: {{ userModel.fetchUsers.error?.message }}
      <button @click="refreshUsers">Повторить</button>
    </div>

    <!-- Список пользователей -->
    <div v-else class="user-list">
      <div 
        v-for="user in userModel.filteredUsers" 
        :key="user.id"
        class="user-item"
        :class="{ selected: userModel.selectedUser?.id === user.id }"
        @click="selectUser(user)"
      >
        <div class="user-info">
          <h3>{{ user.name }}</h3>
          <p>{{ user.email }}</p>
          <span class="role-badge">{{ user.role }}</span>
        </div>
        
        <div class="user-actions">
          <button 
            @click.stop="editUser(user)"
            :disabled="userModel.updateUser.isPending"
            class="btn btn-sm btn-primary"
          >
            Редактировать
          </button>
          
          <button 
            @click.stop="deleteUser(user.id)"
            :disabled="userModel.deleteUser.isPending"
            class="btn btn-sm btn-danger"
          >
            Удалить
          </button>
        </div>
      </div>
    </div>

    <!-- Детали пользователя -->
    <div v-if="userModel.hasSelectedUser" class="user-details">
      <h2>Детали пользователя</h2>
      <div class="detail-item">
        <strong>ID:</strong> {{ userModel.selectedUser?.id }}
      </div>
      <div class="detail-item">
        <strong>Имя:</strong> {{ userModel.selectedUser?.name }}
      </div>
      <div class="detail-item">
        <strong>Email:</strong> {{ userModel.selectedUser?.email }}
      </div>
      <div class="detail-item">
        <strong>Роль:</strong> {{ userModel.selectedUser?.role }}
      </div>
      <div class="detail-item">
        <strong>Создан:</strong> {{ formatDate(userModel.selectedUser?.createdAt) }}
      </div>
    </div>

    <!-- Форма создания пользователя -->
    <div v-if="showCreateForm" class="modal">
      <div class="modal-content">
        <h2>Создать пользователя</h2>
        
        <form @submit.prevent="createUser">
          <div class="form-group">
            <label>Имя:</label>
            <input v-model="newUser.name" required />
          </div>
          
          <div class="form-group">
            <label>Email:</label>
            <input v-model="newUser.email" type="email" required />
          </div>
          
          <div class="form-group">
            <label>Роль:</label>
            <select v-model="newUser.role" required>
              <option value="user">Пользователь</option>
              <option value="moderator">Модератор</option>
              <option value="admin">Администратор</option>
            </select>
          </div>
          
          <div class="form-actions">
            <button 
              type="submit"
              :disabled="userModel.createUser.isPending"
              class="btn btn-success"
            >
              <span v-if="userModel.createUser.isPending">Создание...</span>
              <span v-else>Создать</span>
            </button>
            
            <button 
              type="button"
              @click="showCreateForm = false"
              class="btn btn-secondary"
            >
              Отмена
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Форма редактирования пользователя -->
    <div v-if="showEditForm" class="modal">
      <div class="modal-content">
        <h2>Редактировать пользователя</h2>
        
        <form @submit.prevent="updateUser">
          <div class="form-group">
            <label>Имя:</label>
            <input v-model="editUser.name" required />
          </div>
          
          <div class="form-group">
            <label>Email:</label>
            <input v-model="editUser.email" type="email" required />
          </div>
          
          <div class="form-group">
            <label>Роль:</label>
            <select v-model="editUser.role" required>
              <option value="user">Пользователь</option>
              <option value="moderator">Модератор</option>
              <option value="admin">Администратор</option>
            </select>
          </div>
          
          <div class="form-actions">
            <button 
              type="submit"
              :disabled="userModel.updateUser.isPending"
              class="btn btn-primary"
            >
              <span v-if="userModel.updateUser.isPending">Сохранение...</span>
              <span v-else>Сохранить</span>
            </button>
            
            <button 
              type="button"
              @click="showEditForm = false"
              class="btn btn-secondary"
            >
              Отмена
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, inject, onMounted } from 'vue'
import { userModelProvider } from './userProvider'

const userModel = inject(userModelProvider)!

const showCreateForm = ref(false)
const showEditForm = ref(false)
const newUser = ref({ name: '', email: '', role: 'user' })
const editUser = ref({ id: 0, name: '', email: '', role: 'user' })

const refreshUsers = async () => {
  await userModel.fetchUsers.exec()
}

const selectUser = (user: any) => {
  userModel.selectUser(user)
}

const createUser = async () => {
  try {
    await userModel.createUser.exec(newUser.value)
    showCreateForm.value = false
    newUser.value = { name: '', email: '', role: 'user' }
  } catch (error) {
    console.error('Failed to create user:', error)
  }
}

const editUser = (user: any) => {
  editUser.value = { ...user }
  showEditForm.value = true
}

const updateUser = async () => {
  try {
    await userModel.updateUser.exec(editUser.value.id, {
      name: editUser.value.name,
      email: editUser.value.email,
      role: editUser.value.role
    })
    showEditForm.value = false
  } catch (error) {
    console.error('Failed to update user:', error)
  }
}

const deleteUser = async (id: number) => {
  if (confirm('Вы уверены, что хотите удалить этого пользователя?')) {
    try {
      await userModel.deleteUser.exec(id)
    } catch (error) {
      console.error('Failed to delete user:', error)
    }
  }
}

const formatDate = (date: Date | undefined) => {
  if (!date) return ''
  return new Date(date).toLocaleDateString()
}

onMounted(() => {
  refreshUsers()
})
</script>

<style scoped>
.user-management {
  max-width: 1200px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}

.stats {
  display: flex;
  gap: 20px;
  margin-bottom: 20px;
  padding: 15px;
  background: #f8f9fa;
  border-radius: 4px;
}

.stat-item {
  display: flex;
  gap: 10px;
}

.filters {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.search-input {
  flex: 1;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.role-filter {
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.actions {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
}

.btn {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
}

.btn-primary {
  background: #007bff;
  color: white;
}

.btn-success {
  background: #28a745;
  color: white;
}

.btn-danger {
  background: #dc3545;
  color: white;
}

.btn-secondary {
  background: #6c757d;
  color: white;
}

.btn-sm {
  padding: 4px 8px;
  font-size: 12px;
}

.btn:disabled {
  background: #ccc;
  cursor: not-allowed;
}

.loading, .error {
  text-align: center;
  padding: 20px;
  margin: 20px 0;
  border-radius: 4px;
}

.loading {
  background: #d1ecf1;
  color: #0c5460;
}

.error {
  background: #f8d7da;
  color: #721c24;
}

.user-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: 20px;
  margin-bottom: 20px;
}

.user-item {
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 15px;
  cursor: pointer;
  transition: all 0.2s;
}

.user-item:hover {
  border-color: #007bff;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.user-item.selected {
  border-color: #007bff;
  background: #f0f8ff;
}

.user-info h3 {
  margin: 0 0 5px 0;
  color: #333;
}

.user-info p {
  margin: 0 0 10px 0;
  color: #666;
}

.role-badge {
  display: inline-block;
  padding: 2px 8px;
  background: #e9ecef;
  color: #495057;
  border-radius: 12px;
  font-size: 12px;
}

.user-actions {
  display: flex;
  gap: 5px;
  margin-top: 10px;
}

.user-details {
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 20px;
  margin-top: 20px;
}

.detail-item {
  margin-bottom: 10px;
}

.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.5);
  display: flex;
  align-items: center;
  justify-content: center;
}

.modal-content {
  background: white;
  padding: 30px;
  border-radius: 8px;
  min-width: 400px;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}

.form-group input,
.form-group select {
  width: 100%;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.form-actions {
  display: flex;
  gap: 10px;
  margin-top: 20px;
}
</style>
```

## Что демонстрирует этот пример

### 1. CRUD операции
- **Create**: Создание новых пользователей
- **Read**: Загрузка и отображение пользователей
- **Update**: Редактирование существующих пользователей
- **Delete**: Удаление пользователей

### 2. Управление состоянием
- Отслеживание состояний всех действий
- Индикаторы загрузки и ошибок
- Блокировка кнопок во время операций

### 3. Фильтрация и поиск
- Поиск по имени и email
- Фильтрация по роли
- Реактивные вычисляемые свойства

### 4. Валидация и обработка ошибок
- Проверка обязательных полей
- Обработка HTTP ошибок
- Пользовательские сообщения об ошибках

### 5. UI/UX
- Модальные окна для форм
- Подтверждение удаления
- Выделение выбранного пользователя
- Адаптивная сетка

## Расширение примера

### Добавление пагинации

```typescript
export class UserModel extends ProtoModel {
  users: User[] = []
  currentPage = 1
  pageSize = 10
  totalPages = 0

  @action async fetchUsers(page = 1): Promise<void> {
    const response = await fetch(`/api/users?page=${page}&size=${this.pageSize}`)
    const data = await response.json()
    this.users = data.users
    this.currentPage = page
    this.totalPages = data.totalPages
  }

  get paginatedUsers(): User[] {
    const start = (this.currentPage - 1) * this.pageSize
    const end = start + this.pageSize
    return this.filteredUsers.slice(start, end)
  }
}
```

### Добавление сортировки

```typescript
export class UserModel extends ProtoModel {
  sortBy = 'name'
  sortOrder = 'asc'

  setSort(field: string): void {
    if (this.sortBy === field) {
      this.sortOrder = this.sortOrder === 'asc' ? 'desc' : 'asc'
    } else {
      this.sortBy = field
      this.sortOrder = 'asc'
    }
  }

  get sortedUsers(): User[] {
    return this.filteredUsers.sort((a, b) => {
      const aValue = a[this.sortBy as keyof User]
      const bValue = b[this.sortBy as keyof User]
      
      if (this.sortOrder === 'asc') {
        return aValue > bValue ? 1 : -1
      } else {
        return aValue < bValue ? 1 : -1
      }
    })
  }
}
```

### Добавление массовых операций

```typescript
export class UserModel extends ProtoModel {
  selectedUserIds: number[] = []

  @action async deleteMultipleUsers(): Promise<void> {
    for (const id of this.selectedUserIds) {
      await this.deleteUser(id)
    }
    this.selectedUserIds = []
  }

  @action async updateMultipleUsers(updates: UpdateUserData): Promise<void> {
    for (const id of this.selectedUserIds) {
      await this.updateUser(id, updates)
    }
  }

  toggleUserSelection(id: number): void {
    const index = this.selectedUserIds.indexOf(id)
    if (index > -1) {
      this.selectedUserIds.splice(index, 1)
    } else {
      this.selectedUserIds.push(id)
    }
  }
}
```

## Следующие шаги

Теперь, когда вы изучили CRUD пример, вы можете:

1. [Изучить асинхронные операции](/examples/async/)
2. [Познакомиться с вложенными действиями](/examples/nested/)
3. [Вернуться к руководствам](/guides/) 