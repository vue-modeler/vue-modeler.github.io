---
title: '@action'
description: Справочник по декоратору @action в Vue Modeler
---

# @action

Декоратор для объявления асинхронных действий в Vue Modeler. Автоматически создает экземпляры `Action` и управляет их жизненным циклом.

## Синтаксис

```typescript
@action
async methodName(...args: any[]): Promise<void>
```

## Параметры

Декоратор не принимает параметров. Применяется к методам класса.

## Возвращаемое значение

Декоратор модифицирует метод, делая его доступным как экземпляр `Action`.

## Примеры

### Базовое использование

```typescript
import { ProtoModel } from 'vue-modeler'
import { action } from 'vue-modeler/decorator'

export class UserModel extends ProtoModel {
  users = []

  @action async fetchUsers(): Promise<void> {
    const response = await fetch('/api/users')
    this.users = await response.json()
  }
}
```

### С параметрами

```typescript
export class UserModel extends ProtoModel {
  @action async createUser(name: string, email: string): Promise<void> {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, email })
    })
    const newUser = await response.json()
    this.users.push(newUser)
  }
}
```

### С AbortController

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(abortController = new AbortController()): Promise<void> {
    const response = await fetch('/api/users', {
      signal: abortController.signal
    })
    this.users = await response.json()
  }
}
```

### С возвращаемыми значениями

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUser(id: number): Promise<User> {
    const response = await fetch(`/api/users/${id}`)
    return await response.json()
  }

  @action async validateEmail(email: string): Promise<boolean> {
    const response = await fetch('/api/validate-email', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email })
    })
    const result = await response.json()
    return result.isValid
  }
}
```

## Использование в компонентах

### Выполнение действий

```vue
<template>
  <div>
    <button @click="fetchUsers" :disabled="userModel.fetchUsers.isPending">
      {{ userModel.fetchUsers.isPending ? 'Загрузка...' : 'Загрузить' }}
    </button>
    
    <div v-if="userModel.fetchUsers.isError" class="error">
      {{ userModel.fetchUsers.error?.message }}
    </div>
  </div>
</template>

<script setup lang="ts">
import { inject } from 'vue'
import { userModelProvider } from './userProvider'

const userModel = inject(userModelProvider)!

const fetchUsers = async () => {
  await userModel.fetchUsers.exec()
}
</script>
```

### С параметрами

```vue
<template>
  <form @submit.prevent="createUser">
    <input v-model="name" placeholder="Имя" required />
    <input v-model="email" type="email" placeholder="Email" required />
    <button type="submit" :disabled="userModel.createUser.isPending">
      {{ userModel.createUser.isPending ? 'Создание...' : 'Создать' }}
    </button>
  </form>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const name = ref('')
const email = ref('')

const createUser = async () => {
  await userModel.createUser.exec(name.value, email.value)
  name.value = ''
  email.value = ''
}
</script>
```

### С отменой операций

```vue
<template>
  <div>
    <button @click="startFetch">Начать загрузку</button>
    <button @click="cancelFetch" :disabled="!userModel.fetchUsers.isPending">
      Отменить
    </button>
  </div>
</template>

<script setup lang="ts">
let abortController: AbortController | null = null

const startFetch = async () => {
  abortController = new AbortController()
  try {
    await userModel.fetchUsers.exec(abortController)
  } catch (error) {
    if (userModel.fetchUsers.isAbort) {
      console.log('Загрузка отменена')
    }
  }
}

const cancelFetch = () => {
  if (abortController) {
    abortController.abort('User cancelled')
  }
}
</script>
```

## Ограничения

### Только для методов класса

```typescript
export class UserModel extends ProtoModel {
  // ✅ Правильно - метод класса
  @action async fetchUsers(): Promise<void> {
    // Логика
  }

  // ❌ Неправильно - не метод класса
  const fetchUsers = @action async () => {
    // Логика
  }
}
```

### Только для функций

```typescript
export class UserModel extends ProtoModel {
  // ✅ Правильно - функция
  @action async fetchUsers(): Promise<void> {
    // Логика
  }

  // ❌ Неправильно - не функция
  @action users = []
}
```

### Только в классах ProtoModel

```typescript
// ✅ Правильно - в классе ProtoModel
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    // Логика
  }
}

// ❌ Неправильно - не в классе ProtoModel
export class RegularClass {
  @action async fetchUsers(): Promise<void> {
    // Логика
  }
}
```

## Вложенные действия

### Вызов других действий

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    const response = await fetch('/api/users')
    this.users = await response.json()
  }

  @action async fetchUserDetails(userId: number): Promise<void> {
    const response = await fetch(`/api/users/${userId}/details`)
    const details = await response.json()
    // Обработка деталей
  }

  @action async fetchAllUserData(): Promise<void> {
    // Сначала загружаем список пользователей
    await this.fetchUsers()
    
    // Затем загружаем детали для каждого пользователя
    for (const user of this.users) {
      await this.fetchUserDetails(user.id)
    }
  }
}
```

### Условное выполнение

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    const response = await fetch('/api/users')
    this.users = await response.json()
  }

  @action async processUsers(): Promise<void> {
    // Проверяем состояние другого действия
    if (this.fetchUsers.isReady) {
      // Обрабатываем пользователей
      for (const user of this.users) {
        await this.processUser(user)
      }
    } else {
      throw new Error('Users not loaded')
    }
  }

  private async processUser(user: any): Promise<void> {
    // Логика обработки пользователя
  }
}
```

## Обработка ошибок

### Автоматическая обработка

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    try {
      const response = await fetch('/api/users')
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      this.users = await response.json()
    } catch (error) {
      // Ошибка автоматически сохраняется в action.error
      console.error('Failed to fetch users:', error)
      throw error
    }
  }
}
```

### Пользовательские ошибки

```typescript
export class UserModel extends ProtoModel {
  @action async createUser(userData: any): Promise<void> {
    try {
      // Валидация данных
      if (!userData.name || !userData.email) {
        throw new Error('Name and email are required')
      }

      const response = await fetch('/api/users', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(userData)
      })

      if (!response.ok) {
        throw new Error(`Failed to create user: ${response.statusText}`)
      }

      const newUser = await response.json()
      this.users.push(newUser)
    } catch (error) {
      console.error('Failed to create user:', error)
      throw error
    }
  }
}
```

## Лучшие практики

### Именование действий

```typescript
export class UserModel extends ProtoModel {
  // ✅ Хорошо - глаголы в инфинитиве
  @action async fetchUsers(): Promise<void> { }
  @action async createUser(): Promise<void> { }
  @action async updateUser(): Promise<void> { }
  @action async deleteUser(): Promise<void> { }

  // ❌ Плохо - существительные
  @action async users(): Promise<void> { }
  @action async data(): Promise<void> { }
}
```

### Разделение ответственности

```typescript
export class UserModel extends ProtoModel {
  // ✅ Хорошо - одно действие, одна ответственность
  @action async fetchUsers(): Promise<void> {
    const response = await fetch('/api/users')
    this.users = await response.json()
  }

  @action async createUser(userData: any): Promise<void> {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData)
    })
    const newUser = await response.json()
    this.users.push(newUser)
  }

  // ❌ Плохо - слишком много ответственности
  @action async handleUsers(): Promise<void> {
    // Загрузка, создание, обновление, удаление - все в одном методе
  }
}
```

### Типизация

```typescript
interface CreateUserData {
  name: string
  email: string
  role?: string
}

export class UserModel extends ProtoModel {
  @action async createUser(userData: CreateUserData): Promise<void> {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData)
    })
    const newUser = await response.json()
    this.users.push(newUser)
  }
}
```

### Обработка ошибок

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    try {
      const response = await fetch('/api/users')
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      this.users = await response.json()
    } catch (error) {
      console.error('Failed to fetch users:', error)
      
      // Можно добавить дополнительную логику
      if (error instanceof TypeError) {
        throw new Error('Network error - check your connection')
      }
      
      throw error
    }
  }
}
```

## Особенности

### Автоматическое создание Action

Декоратор `@action` автоматически:

- Создает экземпляр `Action` для метода
- Управляет жизненным циклом действия
- Обеспечивает реактивность состояний

### Интеграция с ProtoModel

Декоратор работает только в классах, наследующих от `ProtoModel`:

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    // Логика действия
  }
}
```

### Типизация

Декоратор обеспечивает полную типизацию:

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> { }
  @action async createUser(data: any): Promise<void> { }
}

// В компоненте
const userModel = inject(userModelProvider)!

// Типизированные вызовы
await userModel.fetchUsers.exec()
await userModel.createUser.exec(userData)
```

## Связанные темы

- [Action](/reference/action/)
- [ProtoModel](/reference/proto-model/)
- [Действия](/guides/actions/)
- [Состояния](/guides/states/) 