---
title: Действие (Action)
description: Подробное руководство по созданию и использованию действий в Vue Modeler
---

import { Aside } from '@astrojs/starlight/components';

**Действие** -- это объект с реактивным состоянием, который меняет состояние модели при выполнении, но объявляется как асинхронный метод.

В контексте Vue это новый подход к управлению состоянием, поэтому давайте немного поясним:

1. действие объявляется как асинхронный метод класса модели с декоратором `@action`, который меняет состояние модели и не возвращает данные
2. действие становится объектом поле создания модели.
3. для выполнения действия используется метод `exec(...)`.
4. действие меняет своё состояние при выполнении, отслеживает ошибки и сохраняет аргументы последнего вызова.
5. действие сохраняет контекст модели, которой принадлежит.


По свойствам и по поведению Действие похож на шаблон проектирования "Команда".

**Характеристики действий:**

- **Асинхронность**. Действие работает с внешними источниками: сохраняет в БД, отправляет на сервер, поэтому всегда асинхронно 
- **Не возвращает данных**. Результат выполнения - это новое состояние внутри модели или ошибка, а не возвращаемые данные.

## В чем преимущество?

Действие как объект:

 - избавляет от шаблонного кода для отслеживания состояния выполнения
 - избавляет от когнитивной нагрузки и позволяет сконцентрироваться на бизнес-логике
 - делает код одинаковым для получения состояния выполнения, обработки ошибок, блокировки, отмены
 - обрабатывает особые случаи (отмена, блокировка, повторный вызов), не нужно изобретать велосипед

Объем кода с использованием действий меньше в разы, чем без. Вот наглядный пример.

**Без действий (шаблонный код):**
```typescript
export const useCart = defineStore('cart', () => {
  const items = shallowRef<Product[]>([])
  // Флаги выполнения операции
  const isAddingProduct = ref(false)
  const addError = ref<Error | null>(null)

  async addProduct(product: Product): Promise<void> {
    // Проверяем, что операция не выполняется
    if (this.isAddingProduct.value) return
    // Устанавливаем флаг выполнения операции
    this.isAddingProduct.value = true
    // Сбрасываем ошибку
    this.addError.value = null
    // Выполняем операцию
    try {
      await api.addToCart(product)
      // Сохраняем новое состояние в модели
      this.items = [...this.items, product]
    } catch (error) {s
      // Сохраняем ошибку
      this.addError.value = error
      // Пробрасываем ошибку дальше
      throw error
    } finally {
      // Сбрасываем флаг выполнения операции
      this.isAddingProduct.value = false
    }
  }

  return {
    items,
    isAddingProduct,
    addError,
    addProduct
  }
})

const cart = useCart()
await cart.addProduct(newProduct)

watch(cart.isAddingProduct, (value) => {
  console.log('isAddingProduct', value)
})

watch(cart.addError, (value) => {
  console.log('addError', value)
})
```

**С действиями:**
```typescript
class Cart extends ProtoModel {
    ...

    @action async addProduct(product: Product): Promise<void> {
        // Отправляем данные на серверы
        await this.apiService.addToCart(product);
        // Сохраняем данные в модели
        this._items.push(product);
    }
}

const cart = Cart.model(apiService);

await cart.addProduct.exec(newProduct);

watch(cart.addProduct.isPending, (value) => {
  console.log('isPending', value)
})

watch(cart.addProduct.error, (value) => {
  console.log('error', value)
})
```

Давайте немного разберемся, что мы видим в коде.

Разработчик пишет шаблонный код для каждой операции изменения состояния: 
1. Устанавливает флаг выполнения операции 
2. Готовит данные для сохранения
3. Сохраняет новое состояние в хранилище 
4. Если сохранение:
    1. **успешно** - коммитит новое состояние в модель
    2. **не успешно** - устанавливает флаг ошибки, ошибка сохраняется или  прокидывается дальше
5. Удаляет флаг выполнения операции

Есть особые случаи:
- Нужно следить, что бы операция не была вызвана, пока не завершился предыдущий вызов, иначе может быть неконсистентное состояние.
- Случается, что операцию нужно отменить или заблокировать.

Это тоже шаблонный код, но разработчики по разному обрабатывают эти случаи. 
Такой код сложно поддерживать и тестировать.

Действие-объект берет на себя всё, включая особые случаи. Позволяет разработчику сконцентрироваться на бизнес-логике (п. 2, 3, 4.1), избавляет от когнитивной нагрузки. Код всех операций стандартизирован и не нужно изобретать велосипед.


## Как использовать действия

Разберем на примере добавления товара в корзину.

```javascript
// Определяем класс модели.
//  Не забываем унаследоваться от ProtoModel. Это обязательно.
class CartModel extends ProtoModel {
    ...

    // Декоратор @action указывает, что это будет действие.
    @action async addProduct(product: Product): Promise<void> {
        // Отправляем данные на серверы
        await this.apiService.addToCart(product);
        // Сохраняем данные в модели
        this._items.push(product);
    }
}


// В комВыполняем действие
cartModel.addProduct.exec(newProduct);

// Следим за статусом выполнения операции
watch(
  cartModel.addProduct.isPending,
  console.log
)
// Следим за ошибками
watch(
  cartModel.addProduct.error,
  console.log
)
```

### Объявляем

Просто добавляем `@action` к асинхронному методу, который не возвращает данных.

```typescript
// Определяем класс модели. Не забываем унаследоваться от ProtoModel.
class CartModel extends ProtoModel {
    ...
    @action async addProduct(product: Product): Promise<void> {
        // Отправляем данные на серверы
        await this.apiService.addToCart(product);
        // Сохраняем данные в модели
        this._items.push(product);
    }
}
```

Обязательные условия:
- Класс должен наследоваться от `ProtoModel`.
- Метод должен возвращать `Promise<void>`.
- Метод должен быть декорирован декоратором `@action`.

### Получаем как объект

**После создания модели действие - это своиство модели и объект.** Для получения действия используйте имя метода, которое было объявлено как действие. TypeScript корректно определяет типы, поэтому автодополнение свойств и методов для действия будет работать.

```typescript
// ✅ Правильно - используем .exec()
await cartModel.addProduct.exec(productId);

// ❌ Неправильно - TypeScript будет ругаться
await cartModel.addProduct(productId);
```

**Внутри класса модели TypeScript видит действие как метод,** но - это объект.  Что бы получить доступ к свойствам и методам действия и избежать ошибок типов TypeScript нужно получить действие через метод `this.action(this.addProduct)`. Он вернет действие с правильными типами и проблем с TypeScript не будет. Теперь действие можно использовать так же, как и в внешнем контексте: выполнять, следить за состоянием и т.п.

```typescript
// ❌ Неправильно. Для TypeScript this.addProduct - это метод,
//  и у него нет свойств
const error = this.addProduct.error;

// ✅ Правильно - получаем действие как объект, и у него есть свойства
const error = this.action(this.addProduct).error;
```

Действия-объект сохраняет контекст модели. Можно безопасно сохранять в переменную и использовать её в других местах.

```typescript

const addProductAction = cart.addProduct;
await addProductAction.exec(productId);

watch(addProductAction.isPending, (value) => {
  console.log('isPending', value)
})

watch(addProductAction.error, (value) => {
  console.log('error', value)
})
```

### Выполняем 

**Во внешнем контексте** получаем действие-объект через свойство модели и вызываем метод `exec(...)`.
`exec(...)` копирует сигнатуру исходного метода, поэтому проверки типов будут работать.

```typescript
// ✅ Правильно - используем .exec()
await cartModel.addProduct.exec(productId);

// ❌ Неправильно - TypeScript будет ругаться, потому что здесь действие уже объект
await cartModel.addProduct(productId);
```

**Внутри класса модели** есть 2 способа выполнить действие:
1. аналогично внешнему контексту: получить как объект через `this.action(this.addProduct)` и вызвать метод `exec(...)`.
2. вызвать действие как метод модели: `this.addProduct(newProduct)`. Это возможно, потому что TS "видит" действие как метод внутри класса.


```typescript
// ❌ Неправильно. Внутри класса так не работает,
// потому что TypeScript видит действие как метод,
// а не как объект.
await this.addProduct.exec(productId);

// ✅ Правильно: получаем как объект,
await this.action(this.addProduct).exec(productId);

// ✅ Так тоже можно, если нужно проверить состояние
const addProductAction = this.action(this.addProduct);
await addProductAction.exec(productId);
if (addProductAction.error) {
  // Обрабатываем ошибку
}

// ✅ Правильно: вызываем действие как метод модели
await this.addProduct(productId);
```

<Aside type="note">
**Вызов как метода != вызов метода.** Декоратор `@action` подменяет оригинальный метод и "под капотом" получает действие как объект и вызывает метод `exec(...)`. try...catch не будет работать, как ожидается. См. [Обработка ошибок](/guides/actions/#обрабатываем-ошибки).
</Aside>

### Следим за состоянием 

У действия есть 5 состояний, для каждого из них определено свойство:

| Свойство | Тип | Описание |
|----------|-----|-----------|
| `isReady` | `boolean` | Действие готово к выполнению |
| `isPending` | `boolean` | Действие выполняется |
| `isAbort` | `boolean` | Действие отменено |
| `isLock` | `boolean` | Действие заблокировано |
| `error` | `null \| ActionError` | Ошибка выполнения |

Свойства реактивны, поэтому можно использовать их в шаблонах, в computed свойствах и в watch.

**Матрица состояний:**

| Состояние | Ready | Pending | Error | Abort | Lock |
|-----------|-------|---------|--------|------|------|
| **Ready ->**     | ❌    | ✅      | ❌     | ❌   | ✅   |
| **Pending ->**   | ✅    | ❌      | ✅     | ✅   | ✅   |
| **Error ->**     | ❌    | ✅      | ❌     | ❌   | ✅   |
| **Abort ->**     | ❌    | ✅      | ❌     | ❌   | ❌   |
| **Lock ->**      | ✅    | ❌      | ❌     | ❌   | ❌   |

Переходы между состояниями строго определены.
Попытка выполнить действие в неверном состоянии приведет к ошибке.

### Обрабатываем ошибки 

Любое действие может завершиться с ошибкой. Метод `exec(...)` перехватывает все ошибки, оборачивает `ActionError` и сохраняет в объекте действия  в свойстве `error`. Рассмотрим 3 случая обработки ошибок:

1. Получение оригинальной ошибки 
2. Проброс ошибки дальше 
3. Проверка типа ошибки и её обработка




### С AbortController

```typescript
@action async fetchUsers(abortController = new AbortController()): Promise<void> {
  const response = await fetch('/api/users', {
    signal: abortController.signal
  })
  this.users = await response.json()
}

// Выполнение с возможностью отмены
const abortController = new AbortController()
const promise = userModel.fetchUsers.exec(abortController)

// Отмена действия
abortController.abort()
```

## Управление жизненным циклом

### Блокировка действий

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    // Логика загрузки
  }

  async performComplexOperation() {
    // Блокируем действие
    await this.fetchUsers.lock()
    
    try {
      // Выполняем сложную операцию
      await this.processData()
    } finally {
      // Разблокируем действие
      this.fetchUsers.unlock()
    }
  }
}
```

### Сброс ошибок

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    // Логика, которая может вызвать ошибку
  }

  async retryFetch() {
    // Сбрасываем ошибку
    this.fetchUsers.resetError()
    
    // Повторяем попытку
    await this.fetchUsers.exec()
  }
}
```

### Отмена действий

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(abortController = new AbortController()): Promise<void> {
    const response = await fetch('/api/users', {
      signal: abortController.signal
    })
    this.users = await response.json()
  }

  async cancelFetch() {
    // Отменяем действие
    await this.fetchUsers.abort('User cancelled')
  }
}
```

## Вложенные действия

Действия могут вызывать другие действия:

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    const response = await fetch('/api/users')
    this.users = await response.json()
  }

  @action async fetchUserDetails(userId: number): Promise<void> {
    const response = await fetch(`/api/users/${userId}/details`)
    const details = await response.json()
    // Обработка деталей
  }

  @action async fetchAllUserData(): Promise<void> {
    // Сначала загружаем список пользователей
    await this.fetchUsers()
    
    // Затем загружаем детали для каждого пользователя
    for (const user of this.users) {
      await this.fetchUserDetails(user.id)
    }
  }
}
```

## Обработка ошибок

### Автоматическая обработка

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    try {
      const response = await fetch('/api/users')
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      this.users = await response.json()
    } catch (error) {
      // Ошибка автоматически сохраняется в action.error
      console.error('Failed to fetch users:', error)
      throw error // Перебрасываем ошибку для обработки в UI
    }
  }
}
```

### Проверка ошибок в UI

```vue
<template>
  <div>
    <div v-if="userModel.fetchUsers.isError" class="error">
      Ошибка загрузки: {{ userModel.fetchUsers.error?.message }}
      <button @click="retryFetch">Повторить</button>
    </div>
    
    <ul v-else>
      <li v-for="user in userModel.users" :key="user.id">
        {{ user.name }}
      </li>
    </ul>
  </div>
</template>

<script setup lang="ts">
const retryFetch = async () => {
  userModel.fetchUsers.resetError()
  await userModel.fetchUsers.exec()
}
</script>
```

## Типизация действий

### С параметрами

```typescript
interface CreateUserData {
  name: string
  email: string
  role?: string
}

export class UserModel extends ProtoModel {
  @action async createUser(userData: CreateUserData): Promise<void> {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData)
    })
    const newUser = await response.json()
    this.users.push(newUser)
  }
}

// Использование с типизацией
await userModel.createUser.exec({
  name: 'John Doe',
  email: 'john@example.com',
  role: 'admin'
})
```

### С возвращаемыми значениями

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUser(id: number): Promise<User> {
    const response = await fetch(`/api/users/${id}`)
    return await response.json()
  }

  @action async validateEmail(email: string): Promise<boolean> {
    const response = await fetch('/api/validate-email', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email })
    })
    const result = await response.json()
    return result.isValid
  }
}
```

## Условное выполнение

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    // Логика загрузки
  }

  async conditionalFetch() {
    // Проверяем, не выполняется ли уже действие
    if (this.fetchUsers.isPending) {
      console.log('Загрузка уже выполняется')
      return
    }

    // Проверяем, есть ли ошибка
    if (this.fetchUsers.isError) {
      console.log('Есть ошибка, сбрасываем')
      this.fetchUsers.resetError()
    }

    // Выполняем действие
    await this.fetchUsers.exec()
  }
}
```

## Мониторинг состояний

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    // Логика загрузки
  }

  get hasAnyPendingActions(): boolean {
    return this.hasPendingActions
  }

  get hasAnyErrors(): boolean {
    return this.hasActionWithError
  }

  get pendingActionsCount(): number {
    // Подсчет выполняющихся действий
    let count = 0
    if (this.fetchUsers.isPending) count++
    // Добавьте другие действия по необходимости
    return count
  }
}
```

## Лучшие практики

### 1. Именование действий

```typescript
export class UserModel extends ProtoModel {
  // ✅ Хорошо - глаголы в инфинитиве
  @action async fetchUsers(): Promise<void> { }
  @action async createUser(): Promise<void> { }
  @action async updateUser(): Promise<void> { }
  @action async deleteUser(): Promise<void> { }

  // ❌ Плохо - существительные или неясные названия
  @action async users(): Promise<void> { }
  @action async data(): Promise<void> { }
  @action async process(): Promise<void> { }
}
```

### 2. Обработка ошибок

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(): Promise<void> {
    try {
      const response = await fetch('/api/users')
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
      
      this.users = await response.json()
    } catch (error) {
      // Логируем ошибку
      console.error('Failed to fetch users:', error)
      
      // Можно добавить дополнительную логику
      if (error instanceof TypeError) {
        // Ошибка сети
        throw new Error('Нет подключения к интернету')
      }
      
      throw error
    }
  }
}
```

### 3. Отмена операций

```typescript
export class UserModel extends ProtoModel {
  @action async fetchUsers(abortController = new AbortController()): Promise<void> {
    try {
      const response = await fetch('/api/users', {
        signal: abortController.signal
      })
      this.users = await response.json()
    } catch (error) {
      if (error.name === 'AbortError') {
        console.log('Запрос отменен')
        return
      }
      throw error
    }
  }
}
```

### 4. Блокировка для предотвращения повторных вызовов

```typescript
export class UserModel extends ProtoModel {
  @action async submitForm(formData: any): Promise<void> {
    // Блокируем действие для предотвращения повторной отправки
    if (this.submitForm.isLock) {
      console.log('Форма уже отправляется')
      return
    }

    await this.submitForm.lock()
    
    try {
      const response = await fetch('/api/submit', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData)
      })
      
      if (!response.ok) {
        throw new Error('Ошибка отправки формы')
      }
    } finally {
      this.submitForm.unlock()
    }
  }
}
```

## Следующие шаги

Теперь, когда вы изучили действия, вы можете:
1. [Изучить состояния подробнее](/guides/states/)
2. [Познакомиться с декораторами](/guides/decorators/)
3. [Изучить обработку ошибок](/guides/error-handling/)
4. [Посмотреть примеры](/examples/) 
