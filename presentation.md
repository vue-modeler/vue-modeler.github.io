# Vue Modeler: ООП для управления состоянием во Vue

---

## План доклада

- Проблемы существующих решений
- Ключевые концепции Vue Modeler
- Быстрый старт
- Модель вместо хранилища
- Действие как объект
- Контейнер зависимостей
- Преимущества подхода

---

## Проблема: шаблонный код в действиях

**Типичный код с Pinia:**

```typescript
const isAddingProduct = ref(false)
const addError = ref<Error | null>(null)

async function addProduct(product: Product) {
  if (isAddingProduct.value) return
  isAddingProduct.value = true
  addError.value = null
  try {
    await api.addToCart(product)
    items.value = [...items.value, product]
  } catch (error) {
    addError.value = error as Error
    throw error
  } finally {
    isAddingProduct.value = false
  }
}
```

**Проблемы:**
- Повторяющийся код для каждого действия
- Нет единого подхода к обработке ошибок
- Сложно отслеживать состояние выполнения

---

## Проблема: отмена и блокировка действий

**Текущая ситуация:**
- Каждый разработчик решает задачу по-своему
- Разные реализации одного паттерна
- Усложняет поддержку и повторное использование

**Нужно:**
- Единый способ отмены операций
- Стандартизированная блокировка действий
- Предсказуемое поведение

---

## Проблема: обработка исключений

**Типичные проблемы:**
- Разработчики забывают обрабатывать ошибки
- Каждый обрабатывает по-своему
- Регламенты не гарантируют корректную обработку
- Требуется внимательное ревью кода

**Последствия:**
- Непредсказуемое поведение приложения
- Плохой пользовательский опыт
- Сложность отладки

---

## Проблема: устаревшие паттерны

**Pinia использует:**
- Фабричную функцию для создания хранилища
- Дополнительные шаблоны для эмуляции наследования
- Ограниченную поддержку полиморфизма

**Результат:**
- Недостаточное использование ООП
- Сложность организации кода
- Ограниченные возможности расширения

---

## Проблема: двойная реактивность

**В Pinia:**
- Хранилище — реактивный объект
- Внутри фабричной функции — реактивные переменные через Reactivity API
- Двойная реактивность на одних данных
- Разные интерфейсы взаимодействия

**Последствия:**
- Избыточная сложность
- Потенциальные проблемы производительности
- Неочевидное поведение

---

## Решение: Vue Modeler

**Две библиотеки:**
- `@vue-modeler/dc` — контейнер зависимостей
- `@vue-modeler/model` — библиотека для создания моделей

**Ключевые принципы:**
- Модель вместо хранилища
- Действие — это объект
- ООП из коробки
- Меньше шаблонного кода

---

## Концепция 1: Модель вместо хранилища

**Нет глобального хранилища:**
- Состояние инкапсулировано в модели
- Модель — shallow reactive объект
- Уничтожение модели = уничтожение состояния
- Вне модели состояние доступно только для чтения

**Преимущества:**
- Нет проблем с глобальным состоянием
- Автоматическая очистка ресурсов
- Простое тестирование

---

## Концепция 2: Действие — объект

**Внутри класса:**
- Действие — асинхронный метод, меняющий состояние

**Снаружи (в компонентах):**
- Действие — реактивный объект
- Имеет состояние выполнения
- Имеет методы управления

**Результат:**
- Нет шаблонного кода для отслеживания состояния
- Единый интерфейс для всех действий
- Предсказуемое поведение

---

## Концепция 3: ООП из коробки

**Стандартный класс:**
- Наследование от `ProtoModel`
- Наследование, инкапсуляция, полиморфизм
- Деструктор для очистки ресурсов

**Типобезопасность:**
- Все подсказки автодополнения работают
- Внутри и вне контекста класса
- Полная поддержка TypeScript

---

## Быстрый старт: задача

**Создадим счетчик:**
- Увеличение и уменьшение при клике
- Асинхронные действия по 2 секунды
- Блокировка кнопок во время выполнения
- Сброс счетчика в 0
- Напишем тесты

**Этого достаточно для демонстрации преимуществ**

---

## Быстрый старт: класс модели

```typescript
import { ProtoModel, action } from '@vue-modeler/model'

interface ApiService {
  inc: (currentCount: number) => Promise<number>
  dec: (currentCount: number) => Promise<number>
}

export class Counter extends ProtoModel {
  protected _count = 0

  constructor(private apiService: ApiService) {
    super()
  }

  get count(): number {
    return this._count
  }

  @action async increment(): Promise<void> {
    this._count = await this.apiService.inc(this._count)
  }

  @action async decrement(): Promise<void> {
    this._count = await this.apiService.dec(this._count)
  }

  @action async reset(): Promise<void> {
    this._count = 0
  }
}
```

---

## Быстрый старт: использование в компоненте

```vue
<script setup lang="ts">
import { useCounter } from './dc'

const counter = useCounter()

const isBusy = computed(() => 
  counter.increment.isPending 
  || counter.decrement.isPending
  || counter.reset.isPending
)

const error = computed(() => 
  counter.increment.error?.cause 
  || counter.decrement.error?.cause
  || counter.reset.error?.cause
)
</script>

<template>
  <div>
    <div v-if="error">{{ error }}</div>
    <div v-else>Current value: {{ counter.count }}</div>

    <button 
      :disabled="isBusy"
      @click="counter.increment.exec()"
    >
      {{ counter.increment.isPending ? 'increment ...' : 'increment +' }}
    </button>
  </div>
</template>
```

---

## Быстрый старт: что мы получили

**Без шаблонного кода:**
- Нет `isLoading`, `isPending` переменных
- Нет ручной обработки ошибок
- Нет проверок состояния выполнения

**С Vue Modeler:**
- Состояние действия доступно напрямую
- Ошибки обрабатываются автоматически
- Код компонента минимален

---

## Модель: основные понятия

**ProtoModel:**
- Базовый класс для всех моделей
- Создает EffectScope для модели
- Преобразует методы с `@action` в действия
- Очищает эффекты при уничтожении

**Класс модели:**
- Обычный класс, унаследованный от `ProtoModel`
- Определяет структуру состояния
- Определяет действия (методы с `@action`)
- Содержит бизнес-логику

---

## Модель: создание

**Создание модели:**
```typescript
// Это модель (реактивный объект)
const counterModel = Counter.model(new ApiService())

// Это экземпляр класса (НЕ модель)
const counter = new Counter(new ApiService())
```

**Метод `model`:**
- Универсальный именованный конструктор
- Копирует сигнатуру конструктора
- Создает shallow reactive объект
- Превращает действия в объекты

---

## Модель: свойства и реактивность

**Автоматическая реактивность:**
- Публичные и защищенные свойства реактивны
- Приватные свойства не реактивны
- Vue Composition API не нужен

**Рекомендации:**
- Делайте свойства защищенными
- Доступ открывайте через геттеры
- Это инкапсулирует состояние

---

## Действие: что это такое

**Действие — объект первого класса:**
- Объявляется как метод с `@action`
- Преобразуется в объект при создании модели
- Имеет реактивное состояние выполнения
- Имеет методы управления

**Преимущества:**
- Статус выполнения без шаблонного кода
- Отмена и блокировка как методы
- Единообразная обработка ошибок
- Меньше кода в разы

---

## Действие: использование

**Объявление:**
```typescript
@action async addProduct(product: Product): Promise<void> {
  await this.apiService.addToCart(product)
  this._items.push(product)
}
```

**Выполнение:**
```typescript
// Снаружи класса
await cartModel.addProduct.exec(product)

// Внутри класса
await this.addProduct(product)
// или
await this.action(this.addProduct).exec(product)
```

---

## Действие: состояния

**Пять состояний:**
- `isReady` — готово к выполнению
- `isPending` — выполняется
- `isAbort` — отменено
- `isLock` — заблокировано
- `error` — ошибка выполнения

**Свойства реактивны:**
- Можно использовать в `watch`, `computed`
- Автоматически обновляют UI
- Только одно булево свойство `true` в момент времени

---

## Действие: обработка ошибок

**Автоматический перехват:**
- `exec` перехватывает исключения
- Сохраняет в свойстве `error`
- Оборачивает в `ActionError`

**Проверка ошибок:**
```typescript
await action.exec()
if (action.error?.cause instanceof HttpError) {
  console.error('HTTP error:', action.error.cause.message)
}
```

**Важно:**
- `try...catch` не работает
- Проверяйте свойство `error`
- Для проброса используйте `throwCause()`

---

## Действие: отмена выполнения

**Метод `abort()`:**
- Построен на `AbortController`
- Последний аргумент метода — `AbortController`
- Должен быть опциональным

**Пример:**
```typescript
@action async addProduct(
  product: Product,
  abortController = new AbortController(),
): Promise<void> {
  await this.apiService.addProduct(product, abortController)
}

// Отмена
cartModel.addProduct.abort()
```

---

## Контейнер зависимостей

**Проблемы, которые решает:**
- Управление жизненным циклом моделей
- Совместное использование между компонентами
- Отделение бизнес-логики от представления

**Принцип работы:**
- Создает по требованию
- Удаляет когда не нужно
- Автоматически вызывает `destructor`

---

## Контейнер: регистрация

**Создание провайдера:**
```typescript
import { provider } from '@vue-modeler/dc'

export const useCounter = provider(() => 
  Counter.model(apiService)
)
```

**Использование:**
```typescript
// В компоненте
const counter = useCounter()
```

**Особенности:**
- Ленивая загрузка
- Автоматическое удаление
- Поддержка destructor

---

## Контейнер: постоянные экземпляры

**Для сервисов уровня приложения:**
```typescript
const usePersistentService = provider(
  () => new MyService(),
  { persistentInstance: true }
)
```

**Особенности:**
- Сохраняются в памяти после освобождения
- Сохраняют состояние между перезагрузками
- Вложенные провайдеры становятся постоянными автоматически

---

## Преимущество 1: меньше кода

**Сравнение:**
- Pinia: ~60 строк для одного действия
- Vue Modeler: ~10 строк для одного действия

**Результат:**
- Меньше кода — меньше багов
- Проще поддержка
- Быстрее разработка

---

## Преимущество 2: стандартизация

**Единый подход:**
- Все действия работают одинаково
- Стандартная обработка ошибок
- Предсказуемое поведение

**Результат:**
- Легче онбординг новых разработчиков
- Меньше времени на ревью
- Меньше ошибок

---

## Преимущество 3: ООП из коробки

**Стандартные возможности:**
- Наследование
- Инкапсуляция
- Полиморфизм
- Деструктор

**Результат:**
- Организация кода по доменам
- Переиспользование логики
- Простое расширение функциональности

---

## Преимущество 4: простота тестирования

**Тестирование моделей:**
- Не отличается от тестирования обычных классов
- Нет необходимости мокать хранилище
- Простая изоляция зависимостей

**Результат:**
- Меньше кода — меньше тестов
- Быстрее написание тестов
- Выше покрытие тестами

---

## Преимущество 5: типобезопасность

**Полная поддержка TypeScript:**
- Автодополнение везде работает
- Проверка типов на этапе компиляции
- Нет необходимости в дополнительных типах

**Результат:**
- Меньше ошибок в рантайме
- Лучший DX (Developer Experience)
- Быстрее разработка

---

## Преимущество 6: минимальный размер

**Компактная библиотека:**
- Минимальный размер бандла
- Нет лишних зависимостей
- Оптимизированный код

**Результат:**
- Быстрая загрузка приложения
- Меньше трафика
- Лучший UX

---

## Итоги

**Vue Modeler решает:**
- Проблему шаблонного кода
- Проблему обработки ошибок
- Проблему отмены и блокировки
- Проблему устаревших паттернов
- Проблему двойной реактивности

**Результат:**
- Меньше кода
- Больше продуктивности
- Лучшая организация кода
- Проще тестирование

---

## Установка

```bash
# Vue 3
npm install @vue-modeler/dc@^3.0.0 @vue-modeler/model

# Vue 2
npm install @vue-modeler/dc@^2.0.0 @vue-modeler/model
```

**Подключение:**
```typescript
import { createApp } from 'vue'
import { vueModelerDc } from '@vue-modeler/dc'

const app = createApp(App)
app.use(vueModelerDc)
app.mount('#app')
```

---

## Спасибо за внимание!

**Ресурсы:**
- Документация: [vue-modeler.github.io](https://vue-modeler.github.io)
- GitHub: [github.com/vue-modeler](https://github.com/vue-modeler)

**Вопросы?**
